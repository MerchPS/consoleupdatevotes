<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Motionime — Submission Monitor (Votes & Views)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#071428; --card:#0c1624; --muted:#9fb0c8; --accent:#6bc1ff; --accent2:#ff7b7b;
    --glass: rgba(255,255,255,0.03);
  }
  *{box-sizing:border-box;font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;}
  body{margin:0;background:linear-gradient(180deg,#031025 0%, #071735 100%);color:#e6eef8;min-height:100vh;padding:20px;}
  .wrap{max-width:1200px;margin:0 auto}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:14px}
  h1{margin:0;font-size:20px}
  p.lead{margin:4px 0 0;color:var(--muted);font-size:13px}
  .controls{display:flex;gap:8px;align-items:center}
  input[type="text"]{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);padding:8px;border-radius:8px}
  button{background:linear-gradient(90deg,var(--accent),#56a6ff);color:#042035;border:0;padding:8px 12px;border-radius:8px;font-weight:600;cursor:pointer}
  button.alt{background:linear-gradient(90deg,var(--accent2),#ff6b6b); color:#fff}
  .grid{display:grid;grid-template-columns:1fr 360px;gap:12px}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.04);padding:12px;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,0.5)}
  table{width:100%;border-collapse:collapse;margin-top:8px}
  th,td{padding:8px 10px;text-align:left;border-bottom:1px solid rgba(255,255,255,0.03)}
  th{font-size:12px;color:var(--muted);font-weight:600}
  .name{font-weight:600}
  .small{font-size:12px;color:var(--muted)}
  .up{color:#62eb9a;font-weight:700}
  .down{color:#ff9aa2;font-weight:700}
  .muted{color:var(--muted)}
  .log{height:120px;overflow:auto;background:rgba(0,0,0,0.18);padding:8px;border-radius:8px;font-size:13px;color:#dff3ff}
  .spark{height:40px}
  footer{margin-top:12px;color:var(--muted);font-size:13px;text-align:center}
  @media (max-width:980px){ .grid{grid-template-columns:1fr} .controls{flex-wrap:wrap} }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Motionime Monitor — Votes & Views</h1>
        <p class="lead">Read-only monitor for 8 submissions. Fast, robust, and Vercel-friendly. (Poll/manual)</p>
      </div>
      <div class="controls">
        <input id="proxyInput" type="text" placeholder="Optional: custom proxy base (e.g. https://your-proxy.com/fetch?url=)">
        <button id="refreshBtn">Refresh</button>
        <button id="autoBtn" class="alt">Auto: OFF</button>
      </div>
    </header>

    <div class="grid">
      <div class="card">
        <div style="display:flex;align-items:center;justify-content:space-between">
          <div>
            <div class="small muted">Contest</div>
            <div style="font-weight:700">Newcomer Streamer of the Year — MotionIme</div>
            <div class="small muted" id="lastUpdate">Last update: —</div>
          </div>
          <div style="text-align:right">
            <div class="small muted">Auto-refresh interval</div>
            <div style="font-weight:700">2.5s</div>
          </div>
        </div>

        <table id="table">
          <thead>
            <tr>
              <th>ID</th><th>Name</th><th>Votes</th><th>Δ</th><th>Views</th><th>Trend</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>

        <div style="margin-top:10px;display:flex;gap:8px;align-items:center;">
          <div class="small muted">Concurrency:</div>
          <input id="concurrency" type="text" value="6" style="width:60px">
          <div class="small muted">Retries:</div>
          <input id="retries" type="text" value="3" style="width:60px">
        </div>

        <div style="margin-top:10px" class="small muted">Proxy fallbacks used automatically if direct fetch blocked. For reliability use your own proxy and paste URL above.</div>
      </div>

      <div class="card">
        <h3 style="margin-top:0">Status & Console</h3>
        <div id="summary" style="margin-bottom:8px" class="small muted">Ready</div>
        <div id="log" class="log"></div>
        <div style="margin-top:12px">
          <canvas id="overviewChart" height="160"></canvas>
        </div>
      </div>
    </div>

    <footer>Tip: If you get many "fetch failed", run a small proxy (one endpoint that forwards GETs) and paste base URL above. I can help set that up.</footer>
  </div>

<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
(() => {
  // CONFIG
  const SUBMISSIONS = [
    { id: 24087, name: "xxknjt" },
    { id: 24084, name: "boo" },
    { id: 24081, name: "JustDani" },
    { id: 24078, name: "SonMV" },
    { id: 24075, name: "KekeLawar" },
    { id: 24066, name: "searchforemma" },
    { id: 24072, name: "YaraYay" },
    { id: 24069, name: "Wasawho" }
  ];
  const BASE_SUB = id => `https://motionimefest.id/contest/newcomer-streamer-of-the-year/submission/${id}/?cid=23816&cm=1`;
  const PARTICIPATE = "https://motionimefest.id/contest/newcomer-streamer-of-the-year/participate/?cid=23816&cm=1";
  const SUBMISSIONS_LIST = "https://motionimefest.id/contest/newcomer-streamer-of-the-year/submissions/?cid=23816&cm=1&sd=desc&sb=date&cpn=1";

  // Proxy fallbacks (public)
  const PROXY_LIST = [
    url => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
    url => `https://thingproxy.freeboard.io/fetch/${url}`
  ];

  // UI
  const tbody = document.querySelector("#table tbody");
  const logEl = document.getElementById("log");
  const lastUpdateEl = document.getElementById("lastUpdate");
  const summaryEl = document.getElementById("summary");
  const refreshBtn = document.getElementById("refreshBtn");
  const autoBtn = document.getElementById("autoBtn");
  const concurrencyInput = document.getElementById("concurrency");
  const retriesInput = document.getElementById("retries");
  const proxyInput = document.getElementById("proxyInput");

  // Chart overview
  const ctx = document.getElementById('overviewChart').getContext('2d');
  let overviewChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: [],
      datasets: [
        { label: 'YaraYay', data: [], borderColor:'#6bc1ff', fill:false, tension:0.2 },
        { label: 'Wasawho', data: [], borderColor:'#ff7b7b', fill:false, tension:0.2 }
      ]
    },
    options:{ animation:false, responsive:true, scales:{ x:{display:true}, y:{display:true} } }
  });

  // state
  let lastData = {};   // id -> votes
  let sessionHistory = {}; // id -> [votes,...]
  SUBMISSIONS.forEach(s => sessionHistory[s.id] = []);
  let auto = false;
  let autoTimer = null;

  // helpers
  function log(msg, level='info'){
    const ts = new Date().toLocaleTimeString();
    logEl.innerText = `[${ts}] ${msg}\n` + logEl.innerText;
  }

  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

  function parseNumber(s){
    if(!s) return null;
    const cleaned = s.replace(/[^\d]/g,'');
    return cleaned ? parseInt(cleaned,10) : null;
  }

  // fetch with timeout
  async function fetchWithTimeout(url, timeout = 10000){
    const controller = new AbortController();
    const id = setTimeout(()=>controller.abort(), timeout);
    try {
      const res = await fetch(url, { signal: controller.signal, cache: "no-store" });
      clearTimeout(id);
      return res;
    } finally {
      clearTimeout(id);
    }
  }

  // fetch html with retries and proxy fallbacks
  async function fetchHtmlRobust(url, {retries=3, proxies=true, timeout=10000} = {}){
    let attempt = 0;
    let lastErr = null;
    // try direct first
    while(attempt <= retries){
      try{
        const res = await fetchWithTimeout(url, timeout);
        if(!res.ok) throw new Error(`HTTP ${res.status}`);
        const text = await res.text();
        if(/Votes/i.test(text) || /Views/i.test(text) || text.length > 1000){
          // quick check: if looks legitimate return
          return { html: text, usedProxy: false, url };
        }
        // sometimes response ok but content empty / blocked -> throw to try proxy
        throw new Error('Content did not contain expected tokens');
      }catch(err){
        lastErr = err;
        attempt++;
        const backoff = Math.min(3000, 200 * Math.pow(2, attempt));
        await sleep(backoff);
      }
    }
    // try proxies
    if(proxies){
      for(const proxyFn of PROXY_LIST){
        const purl = proxyInput.value ? (proxyInput.value + encodeURIComponent(url)) : proxyFn(url);
        try{
          const res = await fetchWithTimeout(purl, timeout+5000);
          if(res.ok){
            const text = await res.text();
            if(/Votes/i.test(text) || /Views/i.test(text) || text.length > 1000){
              return { html: text, usedProxy: true, proxy: purl };
            } else {
              lastErr = new Error('Proxy response missing expected tokens');
            }
          } else {
            lastErr = new Error('Proxy HTTP ' + res.status);
          }
        }catch(err){
          lastErr = err;
        }
      }
    }
    return { error: lastErr ? lastErr.message : 'unknown' };
  }

  // parse votes/views from html
  function extractVotesViews(html){
    if(!html) return {votes:null, views:null};
    const text = html.replace(/\n/g,' ');
    const v = text.match(/([\d\.,]+)\s*Votes/i);
    const w = text.match(/([\d\.,]+)\s*Views/i);
    return { votes: v ? parseNumber(v[1]) : null, views: w ? parseNumber(w[1]) : null };
  }

  // warming sequence: hit participate & submissions first
  async function warmingSequence(){
    try{
      summaryEl.innerText = 'Warming cache: accessing participate & submissions...';
      log('Warming: participate');
      await fetchHtmlRobust(PARTICIPATE, {retries:1, proxies:true, timeout:7000}).catch(()=>null);
      await sleep(250);
      log('Warming: submissions list');
      await fetchHtmlRobust(SUBMISSIONS_LIST, {retries:1, proxies:true, timeout:7000}).catch(()=>null);
      await sleep(250);
    }catch(e){
      log('Warming failed: ' + e.message, 'warn');
    }
  }

  // main fetch for all submissions with concurrency control
  async function fetchAllOnce(){
    const concurrency = Math.max(1, parseInt(concurrencyInput.value) || 6);
    const retries = Math.max(0, parseInt(retriesInput.value) || 3);
    const pool = [...SUBMISSIONS];
    const results = [];
    let running = 0;

    await warmingSequence();

    summaryEl.innerText = 'Fetching submissions...';
    log(`Start fetch (${pool.length}) concurrency=${concurrency} retries=${retries}`);

    function next(){
      if(pool.length===0) return null;
      const item = pool.shift();
      return fetchOne(item, retries).then(r=>{
        results.push(r);
        return next();
      });
    }

    // start N workers
    const workers = [];
    for(let i=0;i<concurrency;i++){
      workers.push(next());
    }
    await Promise.allSettled(workers);

    // update UI
    updateTable(results);
    lastUpdateEl.innerText = 'Last update: ' + new Date().toLocaleTimeString();
    summaryEl.innerText = `Done (${results.length})`;
    return results;
  }

  // fetch a single submission (use robust fetchHtmlRobust)
  async function fetchOne(sub, retries){
    const url = BASE_SUB(sub.id);
    const probe = await fetchHtmlRobust(url, {retries, proxies:true, timeout:9000});
    if(probe.error){
      log(`${sub.name} (${sub.id}) fetch failed: ${probe.error}`);
      return { id: sub.id, name: sub.name, votes: null, views: null, error: probe.error };
    }
    const {html, usedProxy, proxy} = probe;
    const {votes, views} = extractVotesViews(html);
    return { id: sub.id, name: sub.name, votes, views, usedProxy, proxy };
  }

  // update table UI and chart
  function updateTable(results){
    // sort by votes desc if available
    results.sort((a,b)=>{
      if(a.votes==null && b.votes==null) return 0;
      if(a.votes==null) return 1;
      if(b.votes==null) return -1;
      return b.votes - a.votes;
    });

    tbody.innerHTML = '';
    results.forEach(r=>{
      const prev = lastData[r.id] ?? null;
      const delta = (r.votes != null && prev != null) ? r.votes - prev : (prev==null? 0 : 0);
      const trend = delta>0 ? 'up' : (delta<0 ? 'down' : '');
      // push to session history
      if(r.votes!=null) sessionHistory[r.id].push(r.votes);
      // update lastData
      if(r.votes!=null) lastData[r.id] = r.votes;

      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${r.id}</td>
        <td class="name">${r.name}</td>
        <td>${r.votes!=null? r.votes.toLocaleString() : '<span class="muted">-</span>'}</td>
        <td class="${delta>0?'up':delta<0?'down':''}">${(delta>0? '+'+delta: delta)}</td>
        <td>${r.views!=null? r.views.toLocaleString() : '<span class="muted">-</span>'}</td>
        <td>${r.usedProxy? '<span class="small muted">proxy</span>':''}</td>
      `;
      tbody.appendChild(tr);
    });

    // chart update for two main users (YaraYay 24072 and Wasawho 24069)
    const t = new Date().toLocaleTimeString();
    overviewChart.data.labels.push(t);
    const yArr = sessionHistory[24072] || [];
    const wArr = sessionHistory[24069] || [];
    overviewChart.data.datasets[0].data.push(yArr.length? yArr[yArr.length-1]: null);
    overviewChart.data.datasets[1].data.push(wArr.length? wArr[wArr.length-1]: null);
    // keep limited points
    if(overviewChart.data.labels.length>80){
      overviewChart.data.labels.shift();
      overviewChart.data.datasets.forEach(ds=>ds.data.shift());
    }
    overviewChart.update('none');
  }

  // UI actions
  refreshBtn.addEventListener('click', ()=>{ fetchAllOnce().catch(e=>log('Fetch failed: '+e.message)); });
  autoBtn.addEventListener('click', ()=>{
    auto = !auto;
    autoBtn.innerText = auto ? 'Auto: ON' : 'Auto: OFF';
    autoBtn.classList.toggle('alt', auto);
    if(auto){
      autoTimer = setInterval(()=>{ fetchAllOnce().catch(e=>log('Fetch failed: '+e.message)); }, 2500);
    } else {
      clearInterval(autoTimer);
    }
  });

  // initial render placeholder rows
  function initTable(){
    tbody.innerHTML = '';
    SUBMISSIONS.forEach(s=>{
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${s.id}</td><td class="name">${s.name}</td><td class="muted">-</td><td class="muted">-</td><td class="muted">-</td><td></td>`;
      tbody.appendChild(tr);
    });
  }

  initTable();
  // initial auto-fetch once on load but do not auto-toggle
  fetchAllOnce().catch(e=>log('Initial fetch error: '+e.message));

  // expose for debug
  window.motionimeMonitor = { fetchAllOnce, sessionHistory, lastData, log };
})();
</script>
</body>
</html>
